// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var Promise, Validator, chai, expect, should;

  chai = require('chai');

  should = chai.should();

  expect = chai.expect;

  Promise = require('bluebird');

  Validator = new (require('../lib/validator'));

  describe("Validator", function() {
    it("should return error when any of the validation rule fails", function(done) {
      var data, rules;
      rules = {
        name: "required"
      };
      data = {};
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("name");
        return done();
      });
    });
    it("should validate multiple validation rules and return on first failure", function(done) {
      var data, rules;
      rules = {
        name: "required|alpha"
      };
      data = {
        name: "johny12"
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("name");
        expect(err[0].rule).to.equal("alpha");
        return done();
      });
    });
    it("should validate nested objects when rules are defined as plain objects", function(done) {
      var data, rules;
      rules = {
        profile: {
          name: "required"
        }
      };
      data = {
        profile: {
          name: null
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("profile.name");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should validate nested objects when rules are defined with dot notation", function(done) {
      var data, rules;
      rules = {
        "profile.name": "required"
      };
      data = {
        profile: {
          name: null
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("profile.name");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should not validate nested objects when rules are not nested", function(done) {
      var data, rules;
      rules = {
        name: "required"
      };
      data = {
        name: "something",
        profile: {
          name: null
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should print custom messages for rules when passed", function(done) {
      var data, messages, rules;
      rules = {
        name: "required"
      };
      data = {};
      messages = {
        required: "Name is required"
      };
      return Validator.validate(rules, data, messages).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("name");
        expect(err[0].rule).to.equal("required");
        expect(err[0].message).to.equal(messages.required);
        return done();
      });
    });
    it("should give prefrence to field specific messages over rule specific messages", function(done) {
      var data, messages, rules;
      rules = {
        name: "required"
      };
      data = {};
      messages = {
        required: "Field is required",
        name: {
          required: "Name is required to continue"
        }
      };
      return Validator.validate(rules, data, messages).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("name");
        expect(err[0].rule).to.equal("required");
        expect(err[0].message).to.equal(messages.name.required);
        return done();
      });
    });
    it("should give prefrence to field specific messages over rule specific messages when messages are nested using dot notation", function(done) {
      var data, messages, rules;
      rules = {
        name: "required"
      };
      data = {};
      messages = {
        required: "Field is required",
        "name.required": "Name is required to continue"
      };
      return Validator.validate(rules, data, messages).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("name");
        expect(err[0].rule).to.equal("required");
        expect(err[0].message).to.equal(messages["name.required"]);
        return done();
      });
    });
    it("should not parse data fields with array values when rules defined on them are not nested", function(done) {
      var data, rules;
      rules = {
        binary: "required"
      };
      data = {
        binary: [0, 1]
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should not parse data fields with array values when rules defined on them are not nested even if same key is present under nested data object", function(done) {
      var data, rules;
      rules = {
        binary: "required"
      };
      data = {
        binary: [0, 1],
        data: {
          binary: null
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should not parse data fields with array values when rules defined on them are not nested even if same key is present under nested rule object", function(done) {
      var data, rules;
      rules = {
        data: {
          binary: "required"
        }
      };
      data = {
        data: {
          binary: [0, 1]
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should not parse data fields with array values when rules defined on them are not nested even if same key is present under deeply nested rule object", function(done) {
      var data, rules;
      rules = {
        data: {
          binary: "required",
          another: {
            binary: "required"
          }
        }
      };
      data = {
        data: {
          binary: [0, 1]
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("data.another.binary");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should work fine when duplicate keys inside nested rules and data are all present", function(done) {
      var data, rules;
      rules = {
        data: {
          binary: "required",
          another: {
            binary: "required"
          }
        }
      };
      data = {
        data: {
          binary: [0, 1],
          another: {
            binary: "boom"
          }
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should return error when duplicate keys inside nested rules and data isn't present", function(done) {
      var data, rules;
      rules = {
        data: {
          binary: "required",
          another: {
            binary: "required"
          }
        }
      };
      data = {
        data: {
          binary: [0, 1],
          another: {
            binary: null
          }
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.not.exist(success);
        return done();
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("data.another.binary");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should work fine when nested objects value contains mix of objects and arrays", function(done) {
      var data, rules;
      rules = {
        fullname: "required"
      };
      data = {
        fullname: {
          fullname: {
            firstname: "somename"
          }
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should fail when regex test has not been passed", function(done) {
      var data, rules;
      rules = {
        email: "regex:^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$"
      };
      data = {
        email: 'foo'
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err[0].message).to.match(/regex validation failed/);
        expect(err[0].rule).to.equal('regex');
        return done();
      });
    });
    it("should pass when regex test has been passed", function(done) {
      var data, rules;
      rules = {
        email: "regex:^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$"
      };
      data = {
        email: 'foo@bar.com'
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        return should.not.exist(err);
      });
    });
    it("should return an error when key under validation is under root and same key is present under nested object", function(done) {
      var data, rules;
      rules = {
        fullname: "required",
        firstname: "required"
      };
      data = {
        fullname: {
          firstname: "ook",
          fullname: {
            firstname: "somename"
          }
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        should.exist(err);
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("firstname");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should work fine when rules are defined as an array and there are nested values to be parsed", function(done) {
      var data, rules;
      rules = {
        fullname: ['required'],
        profile: {
          username: ['required']
        }
      };
      data = {
        fullname: "ook"
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("profile.username");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should work fine when rules are defined as an array and there are nested values to be parsed and all data is present", function(done) {
      var data, rules;
      rules = {
        fullname: ['required'],
        profile: {
          username: ['required']
        }
      };
      data = {
        fullname: "ook",
        profile: {
          username: "ook"
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        should.not.exist(err);
        return done();
      });
    });
    it("should work fine when rules are defined as an array and rules schema is dot notated", function(done) {
      var data, rules;
      rules = {
        fullname: ['required'],
        "profile.username": ['required']
      };
      data = {
        fullname: "ook"
      };
      return Validator.validate(rules, data).then(function(success) {
        return should.not.exist(success);
      })["catch"](function(err) {
        expect(err).to.be.an("array");
        expect(err[0].field).to.equal("profile.username");
        expect(err[0].rule).to.equal("required");
        return done();
      });
    });
    it("should work fine when rules are defined as an array and rules schema is dot notated and values are present", function(done) {
      var data, rules;
      rules = {
        fullname: ['required'],
        "profile.username": ['required']
      };
      data = {
        fullname: "ook",
        profile: {
          username: "ook"
        }
      };
      return Validator.validate(rules, data).then(function(success) {
        should.exist(success);
        return done();
      })["catch"](function(err) {
        should.not.exist(err);
        return done();
      });
    });
    it("validate should work fine with simultenaous calls", function(done) {
      var data, rules;
      rules = {
        fullname: ['required']
      };
      data = {
        fullname: ""
      };
      return Promise.map([data, data], function(data) {
        return Validator.validate(rules, data)["catch"](function(errs) {
          return errs;
        });
      }).then(function(all_errs) {
        expect(all_errs[0].length).to.equal(1);
        expect(all_errs[1].length).to.equal(1);
        expect(all_errs[0][0]).to.contain.all.keys(["field", "message", "rule"]);
        return done();
      });
    });
    return it("validateAll should work fine with simultenaous calls", function(done) {
      var data, rules;
      rules = {
        fullname: ['required']
      };
      data = {
        fullname: ""
      };
      return Promise.map([data, data], function(data) {
        return Validator.validateAll(rules, data)["catch"](function(errs) {
          return errs;
        });
      }).then(function(all_errs) {
        expect(all_errs[0].length).to.equal(1);
        expect(all_errs[1].length).to.equal(1);
        expect(all_errs[0][0]).to.contain.all.keys(["field", "message", "rule"]);
        return done();
      });
    });
  });

}).call(this);
