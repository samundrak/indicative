// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";

  /**
   * @author Harminder Virk
   * @since v0.6
   * @description Container of extended rules
   */

  /**
   * @requires IS,LODASH,BLUEBIRD,MOMENT=>(Date library)
   */
  var ExtendedRules, IS, MOMENT, PROMISE, _;

  IS = require("is_js");

  _ = require("lodash");

  PROMISE = require("bluebird");

  MOMENT = require("moment");


  /**
    * @class ExtendedRules
   */

  ExtendedRules = (function() {
    function ExtendedRules() {}


    /**
     * @var {Object} Using validations object and storing methods inside it
     */

    ExtendedRules.prototype.validations = {

      /**
       * Make sure field under validation is accepted
       * @param  {[object]}   data  [global data object]
       * @param  {[string]}   field [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @return {[promise]}  returns final promise
       */
      accepted: function(data, field, message) {
        return new PROMISE(function(resolve, reject) {
          if ((_.has(data, field)) && IS.truthy(data[field])) {
            return resolve("is boolean");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is after {defined} date
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      after: function(data, field, message, args) {
        var date;
        date = args.toString().split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || MOMENT(data[field]).isAfter(date)) {
            return resolve("is after date");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is afterOffsetOf + or - offset
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       *                      args.0  [offset, positive or negative]
       *                      args.1  [type of offset accepted by moment().add]
       *                                Key           Shorthand
       *                                years         y
       *                                quarters      Q
       *                                months        M
       *                                weeks         w
       *                                days          d
       *                                hours         h
       *                                minutes       m
       *                                seconds       s
       *                                milliseconds  ms
       * @return {[promise]}  returns final promise
       */
      afterOffsetOf: function(data, field, message, args) {
        return new PROMISE(function(resolve, reject) {
          var fieldValue, key, offset, pivot, ref, ref1, ref2;
          ref = args.toString().split(","), offset = (ref1 = ref[0]) != null ? ref1 : 0, key = (ref2 = ref[1]) != null ? ref2 : 'days';
          if (!_.has(data, field)) {
            return resolve("empty field");
          }
          fieldValue = MOMENT(data[field]);
          pivot = MOMENT().add(offset, key);
          if (fieldValue.isAfter(pivot)) {
            return resolve("is after date");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is beforeOffsetOf + or - offset
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       *                      args.0  [offset, positive or negative]
       *                      args.1  [type of offset accepted by moment().add]
       *                                Key           Shorthand
       *                                years         y
       *                                quarters      Q
       *                                months        M
       *                                weeks         w
       *                                days          d
       *                                hours         h
       *                                minutes       m
       *                                seconds       s
       *                                milliseconds  ms
       * @return {[promise]}  returns final promise
       */
      beforeOffsetOf: function(data, field, message, args) {
        return new PROMISE(function(resolve, reject) {
          var fieldValue, key, offset, pivot, ref, ref1, ref2;
          ref = args.toString().split(","), offset = (ref1 = ref[0]) != null ? ref1 : 0, key = (ref2 = ref[1]) != null ? ref2 : 'days';
          if (!_.has(data, field)) {
            return resolve("empty field");
          }
          fieldValue = MOMENT(data[field]);
          pivot = MOMENT().add(offset, key);
          if (fieldValue.isBefore(pivot)) {
            return resolve("is before date");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Executes defined regex on value for a given
       * field.
       * @method regex
       * @param  {Object} data    [description]
       * @param  {String} field   [description]
       * @param  {String} message [description]
       * @param  {String} args    [description]
       * @return {Promise}         [description]
       */
      regex: function(data, field, message, args) {
        return new PROMISE(function(resolve, reject) {
          if ((!data[field]) || new RegExp(args).test(data[field])) {
            return resolve("regex passed");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is on {defined} day
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      day: function(data, field, message, args) {
        var day;
        day = args.toString().split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.day(new Date(data[field]), day)) {
            return resolve("is a valid day");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is on {defined} month
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      month: function(data, field, message, args) {
        var month;
        month = args.toString().split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.month(new Date(data[field]), month)) {
            return resolve("is a valid month");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is on {defined} year
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      year: function(data, field, message, args) {
        var year;
        year = args.toString().split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.year(new Date(data[field]), parseInt(year))) {
            return resolve("is a valid year");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is alpha only
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @return {[promise]}  returns final promise
       */
      alpha: function(data, field, message) {
        var letters;
        letters = /^[A-Za-z]+$/;
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || letters.test(data[field])) {
            return resolve("is alpha");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is before {defined} date
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      before: function(data, field, message, args) {
        var date;
        date = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || MOMENT(data[field]).isBefore(date)) {
            return resolve("is after date");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation must be a valid date
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @return {[promise]}  returns final promise
       */
      date: function(data, field, message) {
        var formats;
        formats = ["MM/DD/YYYY", "MM-DD-YYYY", "YYYY-MM-DD", "YYYY/MM/DD"];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || (MOMENT(data[field], formats, true)).isValid()) {
            return resolve("is valid date");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation must be a valid date
       * with specified format
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      dateFormat: function(data, field, message, args) {
        var format;
        format = args.split(",");
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || (MOMENT(data[field], format, true)).isValid()) {
            return resolve("is valid date");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation falls in given array of data
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      "in": function(data, field, message, args) {
        var with_in;
        with_in = args.split(",");
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.inArray(data[field], with_in)) {
            return resolve("is in array");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation does not falls in given array of data
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      notIn: function(data, field, message, args) {
        var with_not_in;
        with_not_in = args.split(",");
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.not.inArray(data[field], with_not_in)) {
            return resolve("is in array");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is required
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @return {[promise]}  returns final promise
       */
      required: function(data, field, message) {
        return new PROMISE(function(resolve, reject) {
          if ((_.has(data, field)) && (IS.existy(data[field])) && (IS.not.empty(data[field]))) {
            return resolve("is present");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is required with additional condition
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      requiredIf: function(data, field, message, args) {
        var ref, value, with_field;
        ref = args.split(","), with_field = ref[0], value = ref[1];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, with_field)) || (IS.not.equal(data[with_field], value)) || (_.has(data, field)) && (IS.existy(data[field])) && (IS.not.empty(data[field]))) {
            return resolve("is equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is required with any of the conditions
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      requiredWithAny: function(data, field, message, args) {
        var intersection, with_any_fields;
        with_any_fields = args.split(",");
        intersection = _.intersection(_.keys(data), with_any_fields);
        return new PROMISE(function(resolve, reject) {
          if ((_.size(intersection)) === 0 || (_.has(data, field)) && (IS.existy(data[field])) && (IS.not.empty(data[field]))) {
            return resolve("is equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is required without
       * any of the conditions
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      requiredWithoutAny: function(data, field, message, args) {
        var intersection, with_any_fields;
        with_any_fields = args.split(",");
        intersection = _.intersection(_.keys(data), with_any_fields);
        return new PROMISE(function(resolve, reject) {
          if ((_.size(intersection)) === (_.size(with_any_fields)) || (_.has(data, field)) && (IS.existy(data[field])) && (IS.not.empty(data[field]))) {
            return resolve("is equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is required with all of the conditions
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      requiredWithAll: function(data, field, message, args) {
        var intersection, with_any_fields;
        with_any_fields = args.split(",");
        intersection = _.intersection(_.keys(data), with_any_fields);
        return new PROMISE(function(resolve, reject) {
          if ((_.size(intersection)) !== (_.size(with_any_fields)) || (_.has(data, field)) && (IS.existy(data[field])) && (IS.not.empty(data[field]))) {
            return resolve("is equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is required without all
       * of the conditions
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      requiredWithoutAll: function(data, field, message, args) {
        var intersection, with_any_fields;
        with_any_fields = args.split(",");
        intersection = _.intersection(_.keys(data), with_any_fields);
        return new PROMISE(function(resolve, reject) {
          if ((_.size(intersection)) !== 0 || (_.has(data, field)) && (IS.existy(data[field])) && (IS.not.empty(data[field]))) {
            return resolve("is equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is same as given field
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      same: function(data, field, message, args) {
        var same_as;
        same_as = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.equal(data[field], data[same_as])) {
            return resolve("is same");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation is equal to the given value
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      equals: function(data, field, message, args) {
        var same_as;
        same_as = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.equal(data[field], same_as)) {
            return resolve("is equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation does not equal to the given value
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      notEquals: function(data, field, message, args) {
        var same_as;
        same_as = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.not.equal(data[field], same_as)) {
            return resolve("is not equal");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation value is different
       * from the given field value
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      different: function(data, field, message, args) {
        var same_as;
        same_as = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.not.equal(data[field], data[same_as])) {
            return resolve("is different");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation must be between given range
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      range: function(data, field, message, args) {
        var end, ref, start;
        ref = args.split(","), start = ref[0], end = ref[1];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || _.inRange(data[field], start, end)) {
            return resolve("is in range");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation value has minimum value of
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      min: function(data, field, message, args) {
        var desired_length;
        desired_length = args.toString().split(",")[0];
        data[field] = typeof data[field] !== 'undefined' ? data[field].toString() : data[field];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || (_.size(data[field])) >= parseInt(desired_length)) {
            return resolve("is different");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation value has maximum value of
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      max: function(data, field, message, args) {
        var desired_length;
        desired_length = args.toString().split(",")[0];
        data[field] = typeof data[field] !== 'undefined' ? data[field].toString() : data[field];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || (_.size(data[field])) <= parseInt(desired_length)) {
            return resolve("is different");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation value has is above the given value
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      above: function(data, field, message, args) {
        var min;
        min = args.toString().split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.above(parseInt(data[field]), parseInt(min))) {
            return resolve("is above");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation value has is above the given value
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      under: function(data, field, message, args) {
        var min;
        min = args.toString().split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.under(parseInt(data[field]), parseInt(min))) {
            return resolve("is under");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure field under validation value has is above the given value
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      includes: function(data, field, message, args) {
        var substring;
        substring = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || _.contains(data[field], substring)) {
            return resolve("does include");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure the field under validation starts with given string
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      startsWith: function(data, field, message, args) {
        var substring;
        substring = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.startWith(data[field], substring)) {
            return resolve("does starts with");
          } else {
            return reject(message);
          }
        });
      },

      /**
       * Make sure the field under validation ends with given string
       * @param  {[object]}   data    [global data object]
       * @param  {[string]}   field   [field to be validated]
       * @param  {[string]}   message [message to be printed]
       * @param  {[string]}   args    [arguments passed along with validator]
       * @return {[promise]}  returns final promise
       */
      endsWith: function(data, field, message, args) {
        var substring;
        substring = args.split(",")[0];
        return new PROMISE(function(resolve, reject) {
          if ((!_.has(data, field)) || IS.endWith(data[field], substring)) {
            return resolve("does ends with");
          } else {
            return reject(message);
          }
        });
      }
    };

    return ExtendedRules;

  })();

  module.exports = ExtendedRules;

}).call(this);
